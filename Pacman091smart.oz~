%% Pacman 000 other %%
functor
import
   Tk
   Input
   Browser
   OS
export
   portPlayer:StartPlayer
define   
   StartPlayer
   TreatStream
   Find
   North
   South
   East
   West
   UpdateStatus
   Walkable
   Move
   W
   F
   BrowserObject
   Mark
   Enqueue
   FindInGraph
   IsMarked
   WhileNotEmpty
   ForEachAdj
   EdgeTo
   Bfs
   Graph
   GenerateGraph
   Append
   Path
   Length
   BrowseGraph
in

%%%%%%%%%%%%%%%%%%%
%%% DEFINITIONS %%%
%%%%%%%%%%%%%%%%%%%

	% We define here the following types :
	% <status> ::= status(p:<position> life:<lives> score:<score> m:<mode> spawn:<position>)
	% <score> ::= 0|1|2|...
   % <graph> ::= <graph>
   %           | <node>
   %           | nil
   % <node> ::= node(p:<position> adj:<adjList>)
   % <adjList> ::= <adjList>
   %             | <position>
   %             | nil
   % <edge> ::= edge(v:<position> w:<position>)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PROCEDURES FOR GRAPH %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   fun{Append L1 L2}
      case L1 of nil then L2
      [] H|T then H|{Append T L2}
      end
   end

% Returns a <graph> generated from the Map
   fun{GenerateGraph Map}
   % Returns a <node> built from <position> (X,Y)
      fun{Node X Y}
	 Point
      % Returns the adjacency list of <point> P. This is a list of <position>.
	 fun{BuildAdj P Adj Acc}
	    case Acc of 4 then Adj
	    [] 0 then 
	       if {Find {North P}} \= 1 then {BuildAdj P {Append Adj [{North P}]} Acc+1}
	       else {BuildAdj P Adj Acc+1} end
	    [] 1 then 
	       if {Find {South P}} \= 1 then {BuildAdj P {Append Adj [{South P}]} Acc+1}
	       else {BuildAdj P Adj Acc+1} end
	    [] 2 then 
	       if {Find {East P}} \= 1 then {BuildAdj P {Append Adj [{East P}]} Acc+1}
	       else {BuildAdj P Adj Acc+1} end
	    [] 3 then 
	       if {Find {West P}} \= 1 then {BuildAdj P {Append Adj [{West P}]} Acc+1}
	       else {BuildAdj P Adj Acc+1} end
	    end
	 end
      in
	 Point = pt(x:X y:Y)
	 node(p:Point adj:{BuildAdj Point nil 0})
      end
   % Returns a list of <node> generated from <position> in de row
      fun{Col R X Y G}
	 case R of nil then G
	 [] H|T then
	    if H \= 1 then {Col T X+1 Y {Append G [{Node X Y}]}}
	    else {Col T X+1 Y G}
	    end
	 end
      end
   % Returns a list of <node>
      fun{Row Map Y G}
	 case Map of nil then GenerateGraph
	 [] H|T then {Row T Y+1 {Append G {Col H 1 Y nil}}}
	 end
      end
   in
      {Row Map 1 nil}
   end

% Updates the list of visited points
% Returns a new list of <position>
   fun{Mark Point M}
      case M of nil then Point|nil
      [] H|T then H|{Mark Point T}
      end
   end

% Pushes the point at the end of the list of
% points to be visited
% Returns a new list of <position>
   fun{Enqueue Point Q}
      case Q of nil then Point|nil
      [] H|T then H|{Enqueue Point T}
      end
   end

% Returns the node corresponding to
% the Point in Graph
   fun{FindInGraph G Point}
      case G of nil then error
      [] H|T then
	 if H.p == Point then H
	 else {FindInGraph T Point}
	 end
      end
   end

% Returns true if P is in M, false if not
   fun{IsMarked P M}
      case M of nil then false
      [] H|T then
	 if P == H then true
	 else {IsMarked P T}
	 end
      end
   end

% Inner function of Bfs that returns the list
% shortest edges
   fun{WhileNotEmpty E M Q}
      V
      Node
      L
      NQ
      fun{DeleteFirst Q}
	 case Q of _|T then T
	 else nil
	 end
      end
      proc{Dequeue Q Head NQueue}
	 case Q of H|_ then Head = H
	 else skip
	 end
	 NQueue = {DeleteFirst Q}
      end
   in
      case Q of nil then E
      else
	 {Dequeue Q V NQ}
	 Node = {FindInGraph Graph V}
	 L = {ForEachAdj V Node.adj E M NQ}
	 {WhileNotEmpty L.1 L.2 L.3}
      end
   end

% Inner function of WhileNotEmpty
   fun{ForEachAdj Point Adj E M Q}
      NEdges
      NMarked
      NQueue
   in
      case Adj of nil then E#M#Q
      [] H|T then
	 if {Not {IsMarked H M}} then
	    NEdges = {EdgeTo H Point E}
	    NMarked = {Mark H M}
	    NQueue = {Enqueue H Q}
	 else
	    NEdges = E
	    NMarked = M
	    NQueue = Q
	 end
	 {ForEachAdj Point T NEdges NMarked NQueue}
      end
   end

   fun{EdgeTo V W E}
      case E of nil then edge(v:V w:W)|nil
      [] H|T then
	 if H.v == V then edge(v:V w:W)|T
	 else H|{EdgeTo V W T}
	 end
      end
   end

% Returns a list of <egde> that can be used to find paths
   fun{Bfs Point}
      NMarked
      NQueue
   in
      NMarked = {Mark Point nil}
      NQueue = {Enqueue Point nil}
      {WhileNotEmpty nil NMarked NQueue}
   end

% Returns the shortest path from From to To, which is
% a list of <position>
   fun{Path To From Edges}
      fun{FindEdge P E}
	 case E of H|T then
	    if H.v == P then H
	    else {FindEdge P T}
	    end
	 end
      end
      fun{Loop E P}
	 if E.w == P then E.v|nil
	 else
	    E.v|{Loop {FindEdge E.w Edges} P}
	 end
      end
   in
      {Loop {FindEdge From Edges} To}
   end

% Returns the length of the path
   fun{Length Path}
      fun{Len Path Acc}
	 case Path of nil then Acc
	 [] _|T then {Len T Acc+1}
	 end
      end
   in
      {Len Path 0}
   end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% NAVIGATION ON THE MAP %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Returns the type of point (0, 1, 2, 3 or 4) at <position> Position
   fun{Find Position}
      R C
   in
      fun{R Y P M}
	 case M of H|T then
	    if Y == P.y then {C 1 P.x H}
	    else {R Y+1 P T} end
	 [] nil then 0
	 end
      end
      fun{C X P Row}
	 case Row of H|T then
	    if X == P then H
	    else {C X+1 P T} end
	 [] nil then 0
	 end
      end
      {R 1 Position Input.map}
   end

	% Returns the <position> north of <position> P
   fun{North P}
      if P.y == 1 then pt(x:P.x y:Input.nRow)
      else pt(x:P.x y:P.y-1)
      end
   end

	% Returns the <position> south of <position> P
   fun{South P}
      if P.y == Input.nColumn then pt(x:P.x y:1)
      else pt(x:P.x y:P.y+1)
      end
   end

	% Returns the <position> east of <position> P
   fun{East P}
      if P.x == Input.nColumn then pt(x:1 y:P.y)
      else pt(x:P.x+1 y:P.y)
      end
   end

	% Returns the <position> west of <position> P
   fun{West P}
      if P.x == 1 then pt(x:Input.nColumn y:P.y)
      else pt(x:P.x-1 y:P.y)
      end
   end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% UPDATES OF PACMAN STATUS AND STRATEGY%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% status is a record that stores the <position>, the remainig lives,
	% the current score and the <mode>
   fun{UpdateStatus Position Life Score Mode Spawn}
      status(p:Position life:Life score:Score m:Mode spawn:Spawn)
   end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MOVE FUNCTIONS AND AUXILARY FUNCTIONS %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Define what the pacman does when she recieves a move(?ID ?P) message
	% Position is the current <position> of the pacman
	% Status is the <tatus> of the pacman
	%  is a record that stores the target to reach and the points to avoid
	% Move returns the new <position> of the pacman
   fun{Move Position}
      if {Find {North Position}} \= 1 then {North Position}
      elseif {Find {South Position}} \= 1 then {South Position}
      elseif {Find {East Position}} \= 1 then {East Position}
      else {West Position}
      end
   end

%%%%%%%%%%%%%%%%%%%%%%%
%%% CORE PROCEDURES %%%
%%%%%%%%%%%%%%%%%%%%%%%
	
   % Browser Object (debugging purpose)   
   W = {New Tk.toplevel tkInit(bg:ivory)}
   {Tk.send wm(geometry W "500x300")}
   F = {New Tk.frame tkInit(parent : W
			    bd     : 3
			    bg     : white
			    relief : groove
			    width  : 450  
			    height : 250)}
   {Tk.send pack(F fill:both padx:10 pady:10 expand:true)}
   BrowserObject = {New Browser.'class' init(origWindow: F)}
   {BrowserObject createWindow}

   proc{BrowseGraph G}
      case G of nil then skip
      [] H|T then {BrowserObject browse(H)}
      end
   end

  % ID is a <pacman> ID
   fun{StartPlayer ID}
      Stream
      Port
      Status
      OutOfBoard
   in
      Graph = {GenerateGraph Input.map}
      {BrowseGraph Graph}
      OutOfBoard = pt(x:Input.nColumn+2 y:Input.nRow+2)
      {NewPort Stream Port}
      thread
	 Status = status(p:OutOfBoard life:Input.nbLives score:0 m:classic spawn:OutOfBoard)
	 {TreatStream Stream Status ID }
      end
      Port
   end

   proc{TreatStream Stream Status IDP} % has as many parameters as you want
      NStatus
   in
      case Stream
      of H|T then
	 case H
	 of getID(ID) then 
	    ID = IDP
	    {TreatStream T Status IDP}
	 [] assignSpawn(P) then
	    NStatus = {UpdateStatus P Status.life 0 classic P}
	    {TreatStream T NStatus IDP}
	 [] move(ID P) then
	    ID = IDP
	    P = {Move Status.p}
	    NStatus = {UpdateStatus P Status.life Status.score Status.m Status.spawn}
	    {TreatStream T NStatus IDP}
	 [] bonusSpawn(P) then
	    {TreatStream T Status IDP}
	 [] pointSpawn(P) then
	    {TreatStream T Status IDP}
	 [] bonusRemoved(P) then
	    {TreatStream T Status IDP}
	 [] pointRemoved(P) then
	    {TreatStream T Status IDP}
	 [] addPoint(Add ID NewScore) then
	    NStatus = {UpdateStatus Status.p Status.life Status.score+Add Status.m Status.spawn}
	    ID = IDP
	    NewScore = NStatus.score
	    {TreatStream T NStatus IDP}
	 [] gotKilled(ID NewLife NewScore) then
	    NStatus = {UpdateStatus Status.spawn Status.life-1 Status.score-Input.penalityKill Status.m Status.spawn}
	    ID = IDP
	    NewLife = NStatus.life
	    NewScore = NStatus.score
	    {TreatStream T NStatus IDP}
	 [] ghostPos(ID P) then
	    {TreatStream T Status IDP}
	 [] killGhost(IDg IDp NewScore) then
	    NStatus = {UpdateStatus Status.p Status.life Status.score+Input.rewardKill Status.m Status.spawn}
	    IDp = IDP
	    NewScore = NStatus.score
	    {TreatStream T NStatus IDP}
	 [] deathGhost(ID) then
	    {TreatStream T Status IDP}
	 [] setMode(M) then 
	    NStatus = {UpdateStatus Status.p Status.life Status.score M Status.spawn}
	    {TreatStream T NStatus IDP}
	 else {TreatStream T Status IDP}
	 end
      else skip
      end
   end

end